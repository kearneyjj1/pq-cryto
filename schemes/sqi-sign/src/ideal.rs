//! Ideal computations in quaternion algebras.
//!
//! This module implements operations on left ideals of maximal orders in
//! quaternion algebras. These ideals correspond to isogenies between
//! supersingular elliptic curves via the Deuring correspondence.
//!
//! # Deuring Correspondence
//!
//! For a supersingular curve E with End(E) ≅ O (a maximal order):
//! - Left O-ideals I correspond to isogenies φ: E → E'
//! - The norm of I equals the degree of φ
//! - Ideal multiplication corresponds to isogeny composition
//!
//! # KLPT Algorithm
//!
//! The KLPT algorithm (Kohel-Lauter-Petit-Tignol) finds elements of
//! specific norm in ideals, which is essential for SQI-SIGN.

use crate::curve::E0;
use crate::isogeny::Isogeny;
use crate::quaternion::{MaximalOrder, Quaternion, Rational};
use num_bigint::BigInt;
use num_traits::{One, Zero};

/// A left ideal of a maximal order.
#[derive(Clone, Debug)]
pub struct LeftIdeal {
    /// Basis for the ideal: I = Z⟨b₁, b₂, b₃, b₄⟩.
    pub basis: [Quaternion; 4],
    /// The maximal order O such that I is a left O-ideal.
    pub order: MaximalOrder,
    /// The norm of the ideal (index in O).
    pub norm: BigInt,
}

impl LeftIdeal {
    /// Creates a new ideal from a basis.
    pub fn new(basis: [Quaternion; 4], order: MaximalOrder, norm: BigInt) -> Self {
        Self { basis, order, norm }
    }

    /// Creates a principal ideal I = Oα.
    ///
    /// The principal ideal generated by α has basis {o₁α, o₂α, o₃α, o₄α}
    /// where {o₁, o₂, o₃, o₄} is a basis for O.
    pub fn principal(order: &MaximalOrder, generator: Quaternion) -> Self {
        // Compute basis: multiply each order basis element by the generator
        let basis = [
            order.basis[0].mul(&generator),
            order.basis[1].mul(&generator),
            order.basis[2].mul(&generator),
            order.basis[3].mul(&generator),
        ];

        // The norm of a principal ideal Oα is |nrd(α)|
        let norm = generator.reduced_norm();
        let norm_int = if norm.den == BigInt::one() {
            if norm.num < BigInt::zero() {
                -&norm.num
            } else {
                norm.num.clone()
            }
        } else {
            // For non-integer norms, compute numerator (simplified)
            norm.num.clone()
        };

        Self {
            basis,
            order: order.clone(),
            norm: norm_int,
        }
    }

    /// Computes the product of two ideals IJ.
    ///
    /// The product ideal has generators {aᵢbⱼ} for basis elements aᵢ ∈ I, bⱼ ∈ J.
    /// We then reduce to a Z-basis of rank 4.
    pub fn mul(&self, other: &LeftIdeal) -> LeftIdeal {
        // Generate all 16 products
        let mut products = Vec::with_capacity(16);
        for i in 0..4 {
            for j in 0..4 {
                products.push(self.basis[i].mul(&other.basis[j]));
            }
        }

        // Reduce to a basis using Hermite Normal Form (simplified)
        // For now, just take the first 4 linearly independent elements
        let basis = hermite_reduce(&products, &self.order.p);

        // Norm of product is product of norms
        let norm = &self.norm * &other.norm;

        LeftIdeal {
            basis,
            order: self.order.clone(),
            norm,
        }
    }

    /// Computes the right order O_R(I) = {α ∈ B : Iα ⊆ I}.
    ///
    /// The right order is the order of the codomain curve under the
    /// Deuring correspondence.
    pub fn right_order(&self) -> MaximalOrder {
        // The right order can be computed as:
        // O_R(I) = {α : bᵢα ∈ I for all basis elements bᵢ}
        //
        // For a principal ideal Oα, O_R(Oα) = α⁻¹Oα (conjugate order)
        //
        // Simplified implementation: return standard order
        // (Full implementation would compute the actual right order)
        MaximalOrder::standard(self.order.p.clone())
    }

    /// Tests if this ideal is equivalent to another.
    ///
    /// Two ideals I, J are equivalent if I = Jα for some α ∈ B*.
    /// This means they correspond to isogenies with the same codomain.
    pub fn is_equivalent(&self, other: &LeftIdeal) -> bool {
        // Two ideals are equivalent iff they have the same right order
        // and their quotient is a principal ideal.
        //
        // Simplified check: compare norms (necessary but not sufficient)
        self.norm == other.norm
    }

    /// Computes the conjugate ideal Ī = {ᾱ : α ∈ I}.
    pub fn conjugate(&self) -> LeftIdeal {
        let basis = [
            self.basis[0].conjugate(),
            self.basis[1].conjugate(),
            self.basis[2].conjugate(),
            self.basis[3].conjugate(),
        ];

        LeftIdeal {
            basis,
            order: self.order.clone(),
            norm: self.norm.clone(),
        }
    }

    /// Checks if an element is in this ideal.
    pub fn contains(&self, q: &Quaternion) -> bool {
        // An element is in I if it can be written as integer combination
        // of basis elements. This requires solving a linear system.
        //
        // Simplified: check if coefficients can be expressed
        // (Full implementation would use lattice membership testing)

        // For now, just check if q is zero (trivially in any ideal)
        q.is_zero()
    }

    /// Scales the ideal by a rational factor.
    pub fn scale(&self, factor: &Rational) -> LeftIdeal {
        let basis = [
            scale_quaternion(&self.basis[0], factor),
            scale_quaternion(&self.basis[1], factor),
            scale_quaternion(&self.basis[2], factor),
            scale_quaternion(&self.basis[3], factor),
        ];

        // Norm scales by |factor|²
        let factor_sq = &(factor * factor);
        let new_norm = if factor_sq.den == BigInt::one() {
            &self.norm * &factor_sq.num
        } else {
            &self.norm * &factor_sq.num / &factor_sq.den
        };

        LeftIdeal {
            basis,
            order: self.order.clone(),
            norm: new_norm,
        }
    }
}

/// Scales a quaternion by a rational.
fn scale_quaternion(q: &Quaternion, factor: &Rational) -> Quaternion {
    Quaternion::new(
        &q.a * factor,
        &q.b * factor,
        &q.c * factor,
        &q.d * factor,
        q.p.clone(),
    )
}

/// Reduces a set of quaternions to a Z-basis using simplified HNF.
fn hermite_reduce(elements: &[Quaternion], p: &BigInt) -> [Quaternion; 4] {
    // Simplified: just return first 4 elements
    // Full implementation would compute Hermite Normal Form
    if elements.len() >= 4 {
        [
            elements[0].clone(),
            elements[1].clone(),
            elements[2].clone(),
            elements[3].clone(),
        ]
    } else {
        // Pad with zeros
        let zero = Quaternion::zero(p.clone());
        let mut result = [zero.clone(), zero.clone(), zero.clone(), zero];
        for (i, elem) in elements.iter().enumerate().take(4) {
            result[i] = elem.clone();
        }
        result
    }
}

/// Computes an ideal connecting two orders with given norm.
///
/// Given maximal orders O₀ and O₁, finds a left O₀-ideal I with
/// right order O₁ and norm N.
pub fn find_connecting_ideal(
    left_order: &MaximalOrder,
    right_order: &MaximalOrder,
    target_norm: &BigInt,
) -> Option<LeftIdeal> {
    // This is the core of KLPT: find an element α such that
    // O₀α has right order O₁ and norm equal to target_norm.
    //
    // The algorithm involves:
    // 1. Represent target_norm as sum of four squares
    // 2. Use strong approximation to find α with nrd(α) = target_norm
    // 3. Verify the right order condition

    // Try to find a suitable generator
    if let Some(generator) = find_norm_element(left_order, target_norm) {
        let ideal = LeftIdeal::principal(left_order, generator);

        // Verify right order matches (simplified check)
        let computed_right = ideal.right_order();
        if computed_right.p == right_order.p {
            return Some(ideal);
        }
    }

    None
}

/// Finds an element of the given norm in an order.
fn find_norm_element(order: &MaximalOrder, target_norm: &BigInt) -> Option<Quaternion> {
    // Try to find α with nrd(α) = target_norm
    // This uses the four-squares representation

    if let Some((a, b, c, d)) = four_squares(target_norm, &order.p) {
        // Construct quaternion with these coefficients
        let q = Quaternion::new(
            Rational::from_int(a),
            Rational::from_int(b),
            Rational::from_int(c),
            Rational::from_int(d),
            order.p.clone(),
        );

        // Verify it's in the order and has correct norm
        if order.contains(&q) {
            let norm = q.reduced_norm();
            if !norm.is_zero() {
                return Some(q);
            }
        }
    }

    // Fallback: try small coefficients
    for a in 0..10 {
        for b in 0..10 {
            let q = Quaternion::new(
                Rational::from_int(BigInt::from(a)),
                Rational::from_int(BigInt::from(b)),
                Rational::zero(),
                Rational::zero(),
                order.p.clone(),
            );
            let norm = q.reduced_norm();
            if norm.num == *target_norm && norm.den == BigInt::one() {
                return Some(q);
            }
        }
    }

    None
}

/// Represents n as a sum of four squares: n = a² + b² + c² + d².
///
/// By Lagrange's four-square theorem, every positive integer can be
/// represented as a sum of four squares.
fn four_squares(n: &BigInt, _p: &BigInt) -> Option<(BigInt, BigInt, BigInt, BigInt)> {
    if n <= &BigInt::zero() {
        return None;
    }

    // Simple brute-force for small n
    let limit = n.sqrt() + BigInt::one();
    let limit_i64 = limit.to_u64_digits().1.first().copied().unwrap_or(100).min(100) as i64;

    for a in 0..=limit_i64 {
        let a_sq = BigInt::from(a * a);
        if &a_sq > n {
            break;
        }

        for b in 0..=limit_i64 {
            let b_sq = BigInt::from(b * b);
            let ab_sq = &a_sq + &b_sq;
            if &ab_sq > n {
                break;
            }

            for c in 0..=limit_i64 {
                let c_sq = BigInt::from(c * c);
                let abc_sq = &ab_sq + &c_sq;
                if &abc_sq > n {
                    break;
                }

                let remainder = n - &abc_sq;
                if let Some(d) = integer_sqrt(&remainder) {
                    if &d * &d == remainder {
                        return Some((
                            BigInt::from(a),
                            BigInt::from(b),
                            BigInt::from(c),
                            d,
                        ));
                    }
                }
            }
        }
    }

    // For large n, use randomized algorithm (simplified)
    None
}

/// Computes integer square root if perfect square.
fn integer_sqrt(n: &BigInt) -> Option<BigInt> {
    if n < &BigInt::zero() {
        return None;
    }
    if n.is_zero() {
        return Some(BigInt::zero());
    }

    let sqrt = n.sqrt();
    if &sqrt * &sqrt == *n {
        Some(sqrt)
    } else {
        None
    }
}

/// Translates an ideal to an isogeny using the Deuring correspondence.
///
/// Given a left O₀-ideal I, computes the corresponding isogeny φ: E₀ → E
/// where End(E₀) ≅ O₀ and End(E) ≅ O_R(I).
pub fn ideal_to_isogeny(ideal: &LeftIdeal) -> Isogeny {
    let p = ideal.order.p.clone();

    // The domain is E₀ (the curve with known endomorphism ring)
    let e0 = E0::new(p.clone());

    // For a principal ideal Oα, the isogeny has degree nrd(α)
    // and can be computed from α.
    //
    // The general algorithm:
    // 1. Factor the ideal norm into prime powers
    // 2. For each prime power, compute the corresponding isogeny step
    // 3. Compose the steps

    // Simplified: compute isogeny of degree = ideal norm
    let degree = ideal.norm.clone();

    // Compute codomain curve (simplified - would need full Deuring)
    // For now, use the same curve (identity-like)
    let codomain = e0.curve.clone();

    Isogeny::new(e0.curve, codomain, degree)
}

/// Translates an isogeny to an ideal using the Deuring correspondence.
///
/// Given an isogeny φ: E₀ → E, computes the corresponding left O₀-ideal I
/// where End(E₀) ≅ O₀.
pub fn isogeny_to_ideal(isogeny: &Isogeny, order: &MaximalOrder) -> LeftIdeal {
    // The ideal corresponding to φ is:
    // I_φ = {α ∈ O₀ : α(ker φ) = 0}
    //
    // This requires computing the action of endomorphisms on the kernel.

    // Simplified: create principal ideal with norm = degree
    let generator = Quaternion::new(
        Rational::from_int(isogeny.degree.clone()),
        Rational::zero(),
        Rational::zero(),
        Rational::zero(),
        order.p.clone(),
    );

    LeftIdeal::principal(order, generator)
}

/// KLPT algorithm for finding elements of specific norm in ideals.
///
/// Given an ideal I and target norm N, finds γ ∈ I with nrd(γ) = N
/// (or close to N with smooth factorization).
///
/// This is the key subroutine for SQI-SIGN: it allows converting
/// arbitrary ideals to equivalent ideals with smooth norm.
pub fn klpt(ideal: &LeftIdeal, target_norm: &BigInt) -> Option<Quaternion> {
    let _p = &ideal.order.p;

    // The KLPT algorithm:
    // 1. Find a "good" representative for the ideal class
    // 2. Enumerate short vectors in a related lattice
    // 3. Check if any has the target norm

    // Step 1: Compute a reduced basis for the ideal
    let basis = &ideal.basis;

    // Step 2: Try linear combinations of basis elements
    // Looking for γ = Σ nᵢbᵢ with nrd(γ) = target_norm

    let search_bound = 10i64; // Small search bound for simplicity

    for n0 in -search_bound..=search_bound {
        for n1 in -search_bound..=search_bound {
            for n2 in -search_bound..=search_bound {
                for n3 in -search_bound..=search_bound {
                    if n0 == 0 && n1 == 0 && n2 == 0 && n3 == 0 {
                        continue;
                    }

                    // Compute γ = n₀b₀ + n₁b₁ + n₂b₂ + n₃b₃
                    let gamma = linear_combination(
                        basis,
                        &[
                            BigInt::from(n0),
                            BigInt::from(n1),
                            BigInt::from(n2),
                            BigInt::from(n3),
                        ],
                    );

                    // Check norm
                    let norm = gamma.reduced_norm();
                    if norm.den == BigInt::one() && norm.num == *target_norm {
                        return Some(gamma);
                    }
                }
            }
        }
    }

    // Extended search: try to find element with smooth norm close to target
    find_smooth_norm_element(ideal, target_norm)
}

/// Computes a linear combination of quaternions.
fn linear_combination(basis: &[Quaternion; 4], coeffs: &[BigInt; 4]) -> Quaternion {
    let p = basis[0].p.clone();
    let mut result = Quaternion::zero(p.clone());

    for (i, coeff) in coeffs.iter().enumerate() {
        let scaled = Quaternion::new(
            &basis[i].a * &Rational::from_int(coeff.clone()),
            &basis[i].b * &Rational::from_int(coeff.clone()),
            &basis[i].c * &Rational::from_int(coeff.clone()),
            &basis[i].d * &Rational::from_int(coeff.clone()),
            p.clone(),
        );
        result = result.add(&scaled);
    }

    result
}

/// Finds an element with smooth norm (product of small primes).
fn find_smooth_norm_element(ideal: &LeftIdeal, _target: &BigInt) -> Option<Quaternion> {
    // Try to find element whose norm is B-smooth and close to target
    // This is useful for constructing isogeny chains

    let basis = &ideal.basis;
    let smoothness_bound = 100u64;

    // Small search
    for n0 in 1..5i64 {
        for n1 in 0..3i64 {
            let gamma = linear_combination(
                basis,
                &[
                    BigInt::from(n0),
                    BigInt::from(n1),
                    BigInt::zero(),
                    BigInt::zero(),
                ],
            );

            let norm = gamma.reduced_norm();
            if norm.den == BigInt::one() && !norm.num.is_zero() {
                if is_smooth(&norm.num, smoothness_bound) {
                    return Some(gamma);
                }
            }
        }
    }

    None
}

/// Checks if n is B-smooth (all prime factors ≤ B).
fn is_smooth(n: &BigInt, bound: u64) -> bool {
    if n.is_zero() || n == &BigInt::one() {
        return true;
    }

    let mut remaining = if n < &BigInt::zero() { -n } else { n.clone() };

    // Trial division by small primes
    let small_primes: Vec<u64> = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47];

    for &p in &small_primes {
        if p > bound {
            break;
        }
        let prime = BigInt::from(p);
        while &remaining % &prime == BigInt::zero() {
            remaining = &remaining / &prime;
        }
    }

    remaining == BigInt::one()
}

/// Represents the response isogeny in compressed form.
///
/// For SQI-SIGN, we need to represent isogenies compactly.
#[derive(Clone, Debug)]
pub struct CompressedIdeal {
    /// Coefficients for the generator relative to order basis.
    pub coefficients: [BigInt; 4],
    /// The norm of the ideal.
    pub norm: BigInt,
}

impl CompressedIdeal {
    /// Compresses an ideal to its minimal representation.
    pub fn compress(ideal: &LeftIdeal) -> Self {
        // Extract generator coefficients (simplified)
        Self {
            coefficients: [
                ideal.basis[0].a.num.clone(),
                ideal.basis[0].b.num.clone(),
                ideal.basis[0].c.num.clone(),
                ideal.basis[0].d.num.clone(),
            ],
            norm: ideal.norm.clone(),
        }
    }

    /// Decompresses to a full ideal.
    pub fn decompress(&self, order: &MaximalOrder) -> LeftIdeal {
        let generator = Quaternion::new(
            Rational::from_int(self.coefficients[0].clone()),
            Rational::from_int(self.coefficients[1].clone()),
            Rational::from_int(self.coefficients[2].clone()),
            Rational::from_int(self.coefficients[3].clone()),
            order.p.clone(),
        );

        LeftIdeal::principal(order, generator)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn test_prime() -> BigInt {
        BigInt::from(431)
    }

    #[test]
    fn test_principal_ideal() {
        let p = test_prime();
        let order = MaximalOrder::standard(p.clone());

        // Create principal ideal generated by 1 + i
        let gen = Quaternion::new(
            Rational::from_int(BigInt::one()),
            Rational::from_int(BigInt::one()),
            Rational::zero(),
            Rational::zero(),
            p,
        );

        let ideal = LeftIdeal::principal(&order, gen);

        // Norm should be |nrd(1+i)| = |1 + 1| = 2
        assert_eq!(ideal.norm, BigInt::from(2));
    }

    #[test]
    fn test_ideal_conjugate() {
        let p = test_prime();
        let order = MaximalOrder::standard(p.clone());

        let gen = Quaternion::new(
            Rational::from_int(BigInt::one()),
            Rational::from_int(BigInt::from(2)),
            Rational::zero(),
            Rational::zero(),
            p,
        );

        let ideal = LeftIdeal::principal(&order, gen);
        let conj = ideal.conjugate();

        // Conjugate should have same norm
        assert_eq!(ideal.norm, conj.norm);
    }

    #[test]
    fn test_four_squares_small() {
        let p = test_prime();

        // 5 = 1² + 2² + 0² + 0² = 1 + 4
        if let Some((a, b, c, d)) = four_squares(&BigInt::from(5), &p) {
            let sum = &a * &a + &b * &b + &c * &c + &d * &d;
            assert_eq!(sum, BigInt::from(5));
        }
    }

    #[test]
    fn test_four_squares_larger() {
        let p = test_prime();

        // 30 should be representable
        if let Some((a, b, c, d)) = four_squares(&BigInt::from(30), &p) {
            let sum = &a * &a + &b * &b + &c * &c + &d * &d;
            assert_eq!(sum, BigInt::from(30));
        }
    }

    #[test]
    fn test_is_smooth() {
        assert!(is_smooth(&BigInt::from(1), 10));
        assert!(is_smooth(&BigInt::from(8), 10)); // 2³
        assert!(is_smooth(&BigInt::from(30), 10)); // 2 × 3 × 5
        assert!(!is_smooth(&BigInt::from(11), 10)); // 11 > 10
    }

    #[test]
    fn test_compressed_ideal() {
        let p = test_prime();
        let order = MaximalOrder::standard(p.clone());

        let gen = Quaternion::new(
            Rational::from_int(BigInt::from(3)),
            Rational::from_int(BigInt::from(4)),
            Rational::zero(),
            Rational::zero(),
            p,
        );

        let ideal = LeftIdeal::principal(&order, gen);
        let compressed = CompressedIdeal::compress(&ideal);
        let decompressed = compressed.decompress(&order);

        assert_eq!(ideal.norm, decompressed.norm);
    }

    #[test]
    fn test_ideal_to_isogeny() {
        let p = test_prime();
        let order = MaximalOrder::standard(p.clone());

        let gen = Quaternion::new(
            Rational::from_int(BigInt::from(2)),
            Rational::zero(),
            Rational::zero(),
            Rational::zero(),
            p,
        );

        let ideal = LeftIdeal::principal(&order, gen);
        let isogeny = ideal_to_isogeny(&ideal);

        // Isogeny degree should match ideal norm
        assert_eq!(isogeny.degree, ideal.norm);
    }
}
